/*
	Project 4
	Purpose of assignment: Create and analyze Hash Tables
	The Program will run through 3 possible scenarios selected by the user:
		1: Table size of 53 - User chooses load ratio (How full the hash table is), Collision
			resolution method, and whether to input data manually or randomly.
		2: Table size of 1009 - Runs through all collision resolution methods at various
			load ratios. The same data is used for each method and not randomly generated each
			time to make sure of accurate results.
		3: Same as part 2; however with a table size of 811 to test Radke's Study in 1970 suggesting
			a table size of (4k+3). 4(202)+3 = 811.
*/

#include <iostream>
	using namespace std;
	
int totalComparisons = 0;
int totalInsertions = 0;


/*
* Node Class - Creates a Node for linked lists
*
* Public Variables: Has "data" as an int that we will store values in, and "next" which is a pointer
* to the next node.
*/	
class Node
{
	public:
		int data; // Integer we input. 
		Node* next; // Pointer to next node in linked list. 
};


/*
* setChooseYourPath - This function is used as a menu selection. It makes sure only values
* between 1-3 are chosen.
*
* Parameters:
* int a - This is the menu selection that the user inputs and is now checked for validity.
*
* Output
* int a - Returns 'a' if it is good data, if not - we use recursion to continually ask again until it is.
*
*/
int setChooseYourPath(int a)
{
	if ( (0<a) && (a<4) ) return a;
	else 
	{
		cout << "Invalid option. Please select an option 1-3. " << endl;
		int value;
		cin >> value;
		setChooseYourPath(value);
	}
}

/*
* setcollisionMethod - This function is used as a menu selection. It makes sure only values
* between 1-4 are chosen.
*
* Parameters:
* int a - This is the menu selection that the user inputs and is now checked for validity.
*
* Output
* int a - Returns 'a' if it is good data, if not - we use recursion to continually ask again until it is.
*
*/
int setcollisionMethod(int a)
{
	if ( (0<a) && (a<5) ) return a;
	else 
	{
		cout << "Invalid collision method. Please select method 1-4. " << endl;
		int value;
		cin >> value;
		setcollisionMethod(value);
	}
}
	

/*
* setLoadRatio - This function takes the value the user provides and turns it into a proper
* percentage by dividing it by 100. It accepts a percentage like "30" for "30%".
*
* Parameters:
* double a - This is the percentage the user gives us.
*
* Output
* double a - Returns 'a' as a proper ratio after being divided by 100.
*
*/
double setLoadRatio(double a)
{
	double loadRatio;
	if ( (0<a) && (a<=100) ) 
	{
		loadRatio = a/100;
		cout << "Load ratio: " << loadRatio << endl;
		return loadRatio;
	}
	else 
	{
		cout << "Please input a number greater than 0 and less than 100. " << endl;
		double ratio;
		cin >> ratio;
		setLoadRatio(ratio);
	}
}

/*
* insertItem - This function inserts an item into our Hash Table. 
*
* Parameters:
* Node* a[] - This is our Hash Table's Array of Node pointers.
* int b - This is the integer we are inserting.
* int c - This is our Hash Table's array size.
* int d - This is our collision method.
*
* Output
* void
*
*/
void insertItem(Node* a[], int b, int c, int d)
{
	//Create a new Node that we will put into the array.
	Node* temp = new Node; // New node.
	temp->data = b; // Insert the data we have. 
	temp->next = NULL; // Make sure it has a link to the next node.

	int key = b%c; // Generate the key by doing %tablesize.
	if (a[key] != NULL) 
	{
		switch (d)
		{
			case 1: // Linear Probing.
			{
				int i=key;
				for (; i<c-1; i++) // Do this as long as i<The highest slot in the array.
				{
					totalComparisons++; // Increase our total comparisons.
					if (a[i+1] == NULL) // Found an open slot!
					{
						a[i+1] = temp;
						break;
					}
					if (i == (c-2)) i=-2; 
					/* We hit the top element. Wrap around to the first element.
					Have to do i=-2 due to post-increment, it immediately gets 
					set to -1, and then 0 is checked first.*/
				}
				break;
			}
			case 2: // Double Hashing.
			{
				bool doneColliding = false;
				int step = 50 - (b%c);
				if ( step <= 0 ) step = 1;
				int newKey = key;
				while (doneColliding == false)
				{
					totalComparisons++; // Increase our total comparisons.
					newKey += step;
					if (newKey>c-1) (newKey%=c);
					if ( (newKey > 0) && (newKey!=b) )
					{
						if (a[newKey] == NULL) 
						{
							a[newKey] = temp;
							doneColliding = true;
						}
					}
				}
				break;
			}
			case 3: // Quadratic Probing.
			{
					int newKey;
					int oldKey = key;
					for(int i=1; i<c-1; i++)
					{
						totalComparisons++; // Increase our total comparisons.
						newKey = oldKey+(i^2);
						if ( newKey > c-1 ) 
						{
							oldKey = 0;
							i=1;
						}
						if(a[newKey] == NULL) 
						{
							totalComparisons++; // Increase our total comparisons.
							//cout << "Found an open slot at element " << newKey << endl;
							a[newKey] = temp;
							break;
						}
					}
				break;
			}
			case 4: // Separate Chaining.
			{
				if (a[key] != NULL) // If this spot isn't null.
				{
					totalComparisons++; // Increase our total comparisons.
					Node* last = a[key]; // Make a Node* so we can check the next spot.
					while(last->next != NULL) // Is that next spot null? If it's not, continue.
					{
						totalComparisons++; // Increase our total comparisons.
						last = last->next; // Set last to the next node to check again.
					}
					last->next = temp; // We found an empty spot! Save our node inside this!
				}
				else a[key] = temp; // If it's null already, just save it.
			}
		}
	}
	else a[key] = temp; // If there's no collision, we're all set to go!
}

/*
* isAlreadyInArray - This function determines if a value is already in an array of integers.
*
* Parameters:
* int a[] - This is the array we will pass it.
* int size - This is the array's size.
* int value - This is the value we are determining if is in the array.
*
* Output
* bool - returns true if it is in the array; false if not.
*
*/
bool isAlreadyInArray(int a[], int size, int value)
{
	bool isInArray = false;
	for (int i=0; i<size; i++)
	{
		if (a[i] == value) isInArray = true;
	}
	return isInArray;
}

/*
* main - This function runs our program.
* It has the possibilty to run any 3 parts of the assignment
*
* Parameters: None
*
* Output
* return 0 - Close the program.
*
*/
int main()
{
	srand(time(NULL)); // Seed our rand() function for later.
	
	cout << endl;
	cout << "(1) Table size of 53, Choose your own Load Ratio, and Collision Method." << endl;
	cout << "(2) Table size of 1009, compares various Load Ratios and Collision Methods." << endl;
	cout << "(3) Table size of 811, compares various Load Ratios and Collision Methods." << endl << endl;
	cout << "Would you like to perform Part 1, 2, or 3? ";
	int chooseYourPath;
	cin >> chooseYourPath;
	chooseYourPath = setChooseYourPath(chooseYourPath);
	cout << endl;
	
	switch(chooseYourPath)
	{
		case 1: // Part 1.
		{
			const int hashTableSize = 53; // Table size. 
			Node* hashTable[hashTableSize]; // Creates the hash table with the table size.
			for (int i=0;i<hashTableSize;i++) hashTable[i] = 0;
			double loadRatio; // Used as user input for the load ratio. 
			cout << "Please enter a load ratio: ";
			cin >> loadRatio;
			loadRatio = setLoadRatio(loadRatio); // Pass the input to the function to set the load ratio.
			cout << endl;
			
			cout << "(1) Linear Probing" << endl;
			cout << "(2) Double Hashing" << endl;
			cout << "(3) Quadratic Hashing" << endl;
			cout << "(4) Separate Chaining" << endl;
			cout << endl;
			cout << "Please input the number representing your collision method: ";
			int collisionMethod;
			cin >> collisionMethod;
			collisionMethod = setcollisionMethod(collisionMethod);
			
			// Check if the user wants to enter data manually or have it generated randomly.
			cout << "Would you like to input your data manually? (y/n) ";
			char answer; // Used for input.
			cin >> answer; // Grab their input.
			if ( (answer == 'y') || (answer == 'Y') ) // Ignore the case for y.
			{
				int numberOfItems = 1; // Number of items in the array. Start at 1 so the load ratio isn't exceeded.
				double currentLoad = (double)numberOfItems/hashTableSize; // Current load of the table.
				while (currentLoad < loadRatio) // This will only be false if the load ratio has been exceeded. 
				{
					int integerToInsert;
					cout << "Please input an integer: ";
					cin >> integerToInsert; // Number we are attempting to insert into the array.
					insertItem(hashTable, integerToInsert, hashTableSize, collisionMethod); // Insert the item.
					cout << "Inserted: " << integerToInsert << " successfully." << endl;
					numberOfItems++; // Increase how many items we have in the array.
					currentLoad = (double)numberOfItems/hashTableSize; // Re-evaluate the current load.
				}
			}
			else
			{
				int numberOfItems = 1; // Number of items in the array. Start at 1 so the load ratio isn't exceeded.
				double currentLoad = (double)numberOfItems/hashTableSize; // Current load of the table.
				while (currentLoad < loadRatio) // This will only be false if the load ratio has been exceeded. 
				{
					int randomInt = (rand()%10000)+1;
					insertItem(hashTable, randomInt, hashTableSize, collisionMethod);
					cout << "Inserted: " << randomInt << " successfully." << endl;
					numberOfItems++; // Increase how many items we have in the array.
					currentLoad = (double)numberOfItems/hashTableSize; // Re-evaluate the current load.			
				}
			}

			char printTableAnswer;
			cout << "Would you like to print the table? (y/n): ";
			cin >> printTableAnswer;
			if ( (printTableAnswer == 'y') || (printTableAnswer == 'Y') )
			{
				for (int i=0; i<hashTableSize;i++) 
				{
					if (hashTable[i] != 0) 
					{
						Node* last = hashTable[i];
						while(last != NULL)
						{
							cout << "Element [" << i << "] contains: " << last->data << endl;
							last = last->next;
						}
					}
					else cout << "Element [" << i << "] is empty! " << endl;
				}
			}
			cout << endl;
			break;
		}
		case 2: // Part 2.
		{
		
			/*
				Generate array of random numbers to insert in order to make sure
				that it is consistently the same across all load ratios
				and collision methods.
			*/
			const int usedNumberSize = 1009;
			int usedNumbers[usedNumberSize];
			for (int i=0; i<usedNumberSize; i++)
			{
				bool haveBadNumber = true;
				int randomInt;
				while (haveBadNumber == true)
				{
					randomInt = (rand()%10000)+1;
					haveBadNumber = isAlreadyInArray(usedNumbers, usedNumberSize, randomInt);
				}
				usedNumbers[i] = randomInt;
			}
			//for(int i=0; i<usedNumberSize; i++) cout << "Element[" <<i<<"]: " << usedNumbers[i] << endl;	
		
			
			const int hashTableSize = 1009; // Table size.
			Node* hashTable[hashTableSize]; // Creates the hash table (Of Node*) with the table size.
			
			for (int i=0;i<hashTableSize;i++) hashTable[i] = 0; // Reset all array items.
			double loadRatio;
			int collisionMethod;
			double loadRatioLoop[4] = { .1, .3, .6, .8 };
			int collisionMethodLoop[4] = { 1, 2, 3, 4 };
			string collisionMethodName[4] = {"Linear Probing", "Double Hashing", "Quadratic Probing", "Separate Chaining" };
			for (int i=0; i<4; i++) // Do this for all different load ratios.
			{
				loadRatio = loadRatioLoop[i];
				for (int j=0; j<4; j++) // Do this for all different collitionmethods.
				{
					for (int i=0;i<hashTableSize;i++) hashTable[i] = 0; // Reset all array items.
					totalComparisons = 0;
					totalInsertions = 0;
					collisionMethod = collisionMethodLoop[j];
					int numberOfItems = 1; 
					// Number of items in the array. Start at 1 so the load ratio isn't exceeded.
					double currentLoad = (double)numberOfItems/hashTableSize; // Current load of the table.
					int currentUsedNumber = 0; // Keeps track of what usedNumber we are checking in usedNumbers[]
					while (currentLoad < loadRatio) // This will only be false if the load ratio has been exceeded. 
					{
						insertItem(hashTable, usedNumbers[currentUsedNumber], hashTableSize, collisionMethod); 
						// Insert the item.
						//cout << "Inserted: " << usedNumbers[currentUsedNumber] << " successfully." << endl;
						currentUsedNumber++; // Go to the next number in our earlier generated array.
						numberOfItems++; // Increase how many items we have in the array.
						totalInsertions++; // Increase our total insertions.
						currentLoad = (double)numberOfItems/hashTableSize; // Re-evaluate the current load.
					}
					cout << "Table Size: " << hashTableSize << endl;
					cout << "Collision Method: " << collisionMethodName[collisionMethod-1] << endl;
					cout << "Max Load Ratio: " << loadRatio << endl;
					cout << "Average Comparisons: " << (double) totalComparisons/totalInsertions << endl << endl;
				}
			}
			break;
		}
		case 3: // Part 3. (Same as part 2, but with a different table size.
		{
		
			/*
				Generate array of random numbers to insert in order to make sure
				that it is consistently the same across all load ratios
				and collision methods.
			*/
			const int usedNumberSize = 811;
			int usedNumbers[usedNumberSize];
			for (int i=0; i<usedNumberSize; i++)
			{
				bool haveBadNumber = true;
				int randomInt;
				while (haveBadNumber == true)
				{
					randomInt = (rand()%10000)+1;
					haveBadNumber = isAlreadyInArray(usedNumbers, usedNumberSize, randomInt);
				}
				usedNumbers[i] = randomInt;
			}
			//for(int i=0; i<usedNumberSize; i++) cout << "Element[" <<i<<"]: " << usedNumbers[i] << endl;	
		
			
			const int hashTableSize = 811; // Table size.
			Node* hashTable[hashTableSize]; // Creates the hash table (Of Node*) with the table size.
			
			for (int i=0;i<hashTableSize;i++) hashTable[i] = 0; // Reset all array items.
			double loadRatio;
			int collisionMethod;
			double loadRatioLoop[4] = { .1, .3, .6, .8 };
			int collisionMethodLoop[4] = { 1, 2, 3, 4 };
			string collisionMethodName[4] = {"Linear Probing", "Double Hashing", "Quadratic Probing", "Separate Chaining" };
			for (int i=0; i<4; i++) // Do this for all different load ratios.
			{
				loadRatio = loadRatioLoop[i];
				for (int j=0; j<4; j++) // Do this for all different collitionmethods.
				{
					for (int i=0;i<hashTableSize;i++) hashTable[i] = 0; // Reset all array items.
					totalComparisons = 0;
					totalInsertions = 0;
					collisionMethod = collisionMethodLoop[j];
					int numberOfItems = 1; 
					// Number of items in the array. Start at 1 so the load ratio isn't exceeded.
					double currentLoad = (double)numberOfItems/hashTableSize; // Current load of the table.
					int currentUsedNumber = 0; // Keeps track of what usedNumber we are checking in usedNumbers[]
					while (currentLoad < loadRatio) // This will only be false if the load ratio has been exceeded. 
					{
						insertItem(hashTable, usedNumbers[currentUsedNumber], hashTableSize, collisionMethod); 
						// Insert the item.
						//cout << "Inserted: " << usedNumbers[currentUsedNumber] << " successfully." << endl;
						currentUsedNumber++; // Go to the next number in our earlier generated array.
						numberOfItems++; // Increase how many items we have in the array.
						totalInsertions++; // Increase our total insertions.
						currentLoad = (double)numberOfItems/hashTableSize; // Re-evaluate the current load.
					}
					cout << "Table Size: " << hashTableSize << endl;
					cout << "Collision Method: " << collisionMethodName[collisionMethod-1] << endl;
					cout << "Max Load Ratio: " << loadRatio << endl;
					cout << "Average Comparisons: " << (double) totalComparisons/totalInsertions << endl << endl;
				}
			}	
		}
	}
	return 0;
}
